h1. MerbAuth - Authentication

MerbAuth's authentication is a high level abstraction of session based authentication in web apps under Merb.

It does not dictate the logic you must use to authenticate consumers of your web application,
or even what these consumers look like.  MerbAuth authentication focuses instead
on providing a framework for you to add your own logic for authentication.  It provides a mechanism
to execute your authentication logic, and store the results in and out of the session if successful.

MerbAuth strives to conform to HTTP specification and returns the correct status on a failed / required login.

h2. Authenticating the session

The Session is used as the place for authentication, with a sprinkling of controller and route helpers.
You can choose to protect a controller action, or a route / group of routes.  
This makes sense to talk about an authenticated session. For example, the session has these methods for
interfacing with an authenticated session.

* session.authenticated?  
  returns true if the session has been
  authenticated.  False otherwise # session.authenticate(controller)
  authenticates the session based on customizable user defined rules 

* session.user                      
  returns the currently authenticated user object 

* session.user= 
  manually sets the currently authenticated user object 

* session.abandon!                  
  sets the session to unauthenticated, and clears all session data i.e. Logout

* session.authenticate!
  authenticates the session against the active strategies

Since Merb lazily loads the session on the request object, authentication is available wherever 
you can access the request object.

h2. Required / Failed Authentication

MerbAuth's authentication makes use of Merbs built in exception handling model to return the correct
HTTP status codes and return login page.  When authentication is required but not found, an Unauthenticated exception
is raised.  This is routed to the Exceptions#unauthenticated controller.  The view for Exceptions#unauthenticated
is in fact the login template.

h2. Consumer (User) Considerations

MerbAuth does not require any particular type of "User" object for your application. It is in fact possible to use any kind
of object as a "User" object provided it can be serialized in and out of the session in some fashion.  If possible
a key should be stored in the session and the user looked up rather than storing complex data in the session.  Of 
course, you can also just use a hash for the "User" and store that in the session directly.  MerbAuth does not
dictate, and leaves it up to your application.

h2. Protecting Your Application

You can protect your application either in the router, or in the controller.  Be careful when using the router 
to apply your authentication requirements.  Remember that it's possible to have multiple routes to 
a single controller/action.  If you want to make sure that a controller action is protected, you should use 
controller level authentication.

h2. How Does Authentication Work?

Authentication is based on the logic you setup for your application.  MerbAuth (core) does not supply any authentication
logic, instead, it allows for you to declare _Strategies_ which are separate pieces of logic, 
one for each type of login required.  

Some examples of strategies are, Password login, OpenID, BasicAuth LDAP etc.

MerbAuth will try each strategy in turn until either one is found that passes, or none pass, at which time the authentication
attempt fails and the Unathenticated exception is raised.  It's worth noting that if you're already logged in, the strategies will
be ignored since the "User" is already authenticated.

h3.  What's In a Strategy?

A strategy is a class in the Merb::Authentication::Strategies namespace that inherits from Merb::Authentication::Strategy.
Your strategy must implement a _run!_ instance method.  For example:

<pre><code>
module Merb::Authentication::Strategies
  class PasswordStrategy &lt Merb::Authentication::Strategy
  
    def run!
      if params[:login] && params[:password]
        user_class.authenticate(params[:login], params[:password])
      end
    end
    
  end
end
</code></pre>

This is what a simple strategy might look like.  Just by declaring it it becomes active and will be used to 
try authentication.  

You can see in the strategy the run! method.  This is where the actual logic resides for authenticating the "User".
If you return something that is not nil or false, i.e. some kind of object, it is considered to be authenticated and
will be serialized into the session.  If you return nil or false, this strategy will fail and the next one will be tried.
If they all fail the request is considered to be unauthenticated.  To have more than one strategy, simply declare more.

Since the Strategy is just a ruby class, you can develop very complex logic to support your authentication requirements
if you need to.

The strategy provides access to:

* the request object  : @request@
* the router params   : @params@

h3. Where should Strategies be defined?

You should store your strategies in 
<pre><code>
  merb
  `-- merb-auth
      |-- setup.rb
      `-- strategies.rb
</code></pre>

This is a good place to put everything together so you can see what you're doing at a glance.
It is also auto included by merb-auth-core when you're using it.

h3. Strategies and Inheritance

Strategies may be inherited multiple times to make the job of combining similar aspects easier.  
You can inherit as many levels as you like and at any point you may mark a strategy as _abstract!_

An abstract strategy just means that it will not be run when it comes time to authenticate.  
Instead it's good to put common logic in and then inherit from it to keep your strategies DRY.

To mark a class as abstract, use the @abstract!@ class method.

<pre><code>
  class AbstractStrategy < Merb::Authentication::Strategy
    abstract!
  end
</code></pre>


h3. What Strategies are there?

See merb-auth-more

h2. Protecting Your Application

h3. Authentication based on Routes

With MerbAuth you can protect routes rather than individual actions on a controller.
The benefit with doing this is that the request is stopped earlier in the request
process.  This is a more efficient method of protection than controller based protection.
The downside is that a controllers action is not guaranteed to be protected.  For example

<pre><code>
  
  authenticate do 
    match("/one").to(:controller => "one", :action => "index")
  end
  
  match("/two").to(:controller => "one", :action => "index")
  
</code></pre> 

The /one route is protected, but you can see that both of these routes point to the same 
controller action.  If the One#index method is accessed through the /two route, there is 
no protection.  You can specify which strategies to use as arguments to the authenticate method.
The default strategies are used if there is no argument given.  You should consider carefully before
specifying which strategy to run however.

h3. Protecting a Controller

If you need to protect an action regardless of which route leads to it, you can use
controller level protection.  Use a @before :ensure_authenticated@ filter to protect actions
in your controller whenever the are accessed.  

It's possible to configure each call to @ensure_authenticated@ with a custom list
of strategies to run.  These will be run in order and should have an instance method
of #run!

<pre><code>
  class ApiMethods < Application
    before :ensure_authenticated, :with => ["Basic::Form", "Basic::BasicAuth", "Basic::OpenID"],
                                  :only => [:index]
    before :machine_only, :only => [:create]
    
    def index
      display @stuff
    end

    def create
      stuff = Stuff.create(params[:stuff])
      display stuff
    end
    
    private
    def machine_only
      ensure_authentiated "Basic::OAuth","Basic::BasicAuth"
    end
  end
</code></pre>

You can see in this example that you can specify a list of strategies to use.
These will be executed in the order of the array passed in, with the default order
ignored completely.  You should use this sparingly however.

h2. Session Serialization

You need to tell MerbAuth how to serialize your object into
and out of the session.  If possible try not to store large or complex 
data items in the session but just store the objects key if possible.

To configure your user object to go in and out of the session, here's how you
could do it.

<pre><code>
    class Merb::Authentication

      # return the value you want stored in the session 
      def store_user(user)
        return nil unless user 
        user.id
      end

      # session info is the data you stored in the session previously 
      def fetch_user(session_info)
        User.get(session_info)
      end
    end
</code></pre>

h2. The default User class

MerbAuth tracks a default user class.  This is for the benefit of plugin authors mostly, but also 
allows for easier sharing of login strategies.  To set this use:

@Merb::Authentication.user_class = Person@

Strategies provide a @user_class@ method as seen in the above strategy examples.  
This is a convenience method on a strategy to provide you with the user_class to use for this strategy.  
You can overwrite this method on a per strategy basis to use different user model types.  
You do not _have_ to use this method and it's only there to keep track of the "default" user class. (if any)

By default the strategy#user_class method will defer to Merb::Authentication#user_class.  You can 
set which is the "default class" that Merb::Authentication will use in the provided strategies by
setting it in Merb.root/merb/merb-auth/setup.rb

h32. Providing feedback to users (Error Messages)

There's at least 4 ways to provide feedback to users for failed logins. 

* Use the authentications error messaging inside your strategies to set error messages there.
  You can add to these errors just like adding to DataMappers validation errors.
  
  <pre><code>
    session.authentication.errors.add("Label", "You Fail")
  </code></pre>
  Add as many as you like, ask @session.authentication.errors.on(:label)@ to get specific errors etc
  Really... They're just like the DataMapper validation errors.  The bonus of using this system
  is that you can add messages inside your Strategies, and then in your views you can do this:
  <pre><code>
    <%= error_messages_for sessions.authentication %>
  </pre></code>
* Overwrite Merb::Authentication#error_message  The return of this method is 
  the default message that is passed to the Unauthenticated exception.  Overwrite
  this to provide a very basic catch all message.
* Provide a default message when you declare your before filter.
  <pre><code>
    before :ensure_authenticated, :with => [Openid, :message => "Could not log you in with open ID"]
    # OR
    before :ensure_authentication, :with => {:message => "Sorry Buddy... You Lose"}
  </code></pre>
  When you pass a message, it will replace the Merb::Authentication#error_message default for this
  action
* Use an after filter for your login action.  This can be used to set your flash/messaging system.  For example:
  <pre><code>
    after :set_login_message, :only => [:create]
    private
    def set_login_message
      if session.authenticated?
        flash[:message] = "Welcome"
      else
        flash[:error] = "Bad.. You Fail"
      end
    end
  </code></pre>

h2. Additional checks / actions to perform after the user is found

Sometimes you may need to perform additional operations on the user object
after you have found a valid user in the strategy.  There is a hook method
Merb::Authentication.after_authentication which is designed for this.

Here's an example of checking that a user object is active after it's been
found: 

  Merb::Authentication.after_authentication do |user, request, params|
    user.active? ? user : nil
  end

Pass the user model on if everything is still ok.  Return nil if you decide in the
after_authentication hook that the user should in fact not be allowed to be authenticated.

You can add as many of these as you need to.  The will be run one after the other until either
they're all run, or one of them returns nil/false.

h2. Registering Strategies

Intended for plugin developers as a way to make it easy to use 
strategies there is the possibility to register a strategy without loading it.

<pre><code>
  Merb::Authentication.register(:my_strategy, "/absolute/path/to/strategy.rb")
</code></pre>

This then allows developers to use

<pre><code>
  Merb::Authentication.activate!(:my_strategy)
</pre></code>

To activate a registered strategy:
<pre><code>
  Merb::Authentication.activate!(:defualt_password_form) 
</code></pre>

You can easily mix this in with your own strategies. In you Merb.root/merb-auth/strategies.rb
<pre><code>
module Merb::Authentication::Strategies
  class MyStrategy < Merb::Authentication::Strategy
    def run!
      #...
    end
  end
  
  Merb::Authentication.activate!(:default_openid)
  
  class AnotherStrategy < Merb::Authentication::Strategy
    def run!
      #...
    end
  end
end
</code></pre>

This will collect them in order of declaration.  i.e.:
  "MyStrategy", "Basic::OpenID", "AnotherStrategy"

h2. Initial Contributors 

# Adam French - "http://adam.speaksoutofturn.com/":http://adam.speaksoutofturn.com/
# Daniel Neighman - "http://merbunity.com":http://merbunity.com
# Ben Burket - "http://benburkert.com/":http://benburkert.com/
